'''
Created on Dec 4, 2012

@author: Tanglei
'''

import json


import threading,math 


from collections import deque


import logging
import logging.handlers

#++++++++++++++++++++++++LOG config begin +++++++++++++++++++++
#create logger
logger = logging.getLogger("simple_example")
logger.setLevel(logging.DEBUG)
#create console handler and set level to error
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)
#create file handler and set level to debug  Rotating
fh = logging.handlers.RotatingFileHandler("logs/mobj.log",'a',5120,10) #'spam.log'
fh.setLevel(logging.DEBUG)
#create formatter
#("%(asctime)s - %(name)s - %(levelname)s : %(message)s") 
#%(asctime)s% (levelname)-4s : 
formatter = logging.Formatter(" %(message)s",datefmt='%H:%M:%S')
#add formatter to ch and fh
ch.setFormatter(formatter)
fh.setFormatter(formatter)
#add ch and fh to logger
logger.addHandler(ch)
logger.addHandler(fh)

#++++++++++++++++++++++++LOG config end+++++++++++++++++++++

"""
1 design goal:
	for each motion-region item in an array of motionRegion generated by motion program that contains following attr set:
		{centerX,centerY,H,W,direction,size...
	the vaule of these attr of the item will be updated at about 20fps, and we want to use the princeple of
	Markov module to predict whether the certain shape of region item can become a stable object for a short period if
	no overlap case happens to that region.

"""



class MotionRec(object):
    def __init__(self,x,y,h,w,d,s):
        self.xPos=x;
        self.yPos=y;
        self.height=h;
        self.width=w;
        self.dir=d;
        self.cellSize=s;
        #additonal radial 
        self.radial= math.floor( h/6*1.4+w/6*1.4+math.sqrt( s/1.57 ) ) #assume cellSize fillingRatio is no lowner than 50%
        #self.range = judgeObjRangeOnCreate(self.width,self.height,self.radial,self.cellSize);

class MotionObjectStabilizer(object):

	
	#para
	# 	sendMethod  the function name that take only one plain-string as load to transfer to client side

    def __init__(self,sendMethod):
        self.objmngr = MotionObjMngr()
        self.sendMethod=sendMethod;

    #public
    def startProcess(self):
        #self.objmngr.scanZombie( self.packAndSendAutoUpdateMsg )
        self.objmngr.scanMObjCache(self.sendInternalMsg )

	#public
    def sendExternalMsg(self,jsonMsg):
    	'''
    	This function:
    	1 read jsonMsg from motion program's udp socket
    	2.1 extract its ml element
    	2.2	process the orig ml array by MotionObjectStabilizer
    	2.3 repack the result list into original json
    	3 send the modified json pkg to client 
    	'''

        motionList=jsonMsg["ml"]
        
        if len(motionList)>0:
            
            mList=[] 
            for item in motionList:
                    #gen MotionRec object for each item of orig array-motionRegionList
                    #json format:
                    #item[0 centerX,1 centerY,2 H,3 W,4 direction,5 cellsize...]
                    mList.append(MotionRec(item[0],item[1],item[2],item[3],item[4],item[5] ) );

            stabilizedMotionList = self.__dataProcess__(mList)
            #if len(stabilizedMotionList)>0:
            #    print stabilizedMotionList
        else:
            #even if input ml == emtpy
            # we still deal with existing mObj's HP in cache list
            stabilizedMotionList = self.__dataProcess__([]) 
        
        jsonMsg['ml']=stabilizedMotionList;
        self.sendMethod(json.dumps(jsonMsg)+'\n') #use \n as spliter for json

    #private
    #motionListObj is generated by omposeMObjList method
    def sendInternalMsg(self,motionListObj):
    	'''
    	only used by internal function in this mod to send custom msg to client

    	'''
        temp = {"ft":1,"ml":motionListObj}
        self.sendMethod(json.dumps(temp)+'\n');


    def __dataProcess__(self,motionDataList):

		#Match is the most complicated part in this mod 
		#It compares the input motionDataList with several internal cached data to judge each motionRegion item within the list

        self.objmngr.MatchObj(motionDataList);

        #if updatelist is nothing,objList is []
        objList = self.objmngr.composeMObjList(self.objmngr.updateList)
        
        #only for log now            
        '''
        if (len(objList)>0):
            #print '-len:'+str(len(objList)),
            
            for obj in objList:
                #if obj['op']=='invis' or obj['op']=='vis':#or obj['op']=='update'  :# or obj['op']=='create':
                  
                logger.info( '%d %-8s [%4d,%4d] [%3d,%3d] %d' %(obj["id"], obj['op'],obj["x"], obj["y"],obj["w"],obj["h"],obj["size"] ))
            #self.sender.sendData_pubnub(sectionArr,objList)
        '''
        return objList;



class MotionObjMngr(object):
    def __init__(self):
        #self.execMode= 'udp'; #'db'/'udp'
        self.regID =1;
        self.regOID=2000;

        self.initGhostTime=0.5; #1s,



        #!!!!!!!!!!!!!!!!!
        # fpsNum *initGhostTime *hpDec *80% ~= minHP
        # in the limited turn of ghost period, at least the motion region item who miss 80% matching 
        # will reach the minHP and die without become a real mobj that has a oid.
        #
    	self.minHP=-20;
    	self.hpDec=-2; 

    	# (maxHP+|minHP|)/|hpDec|/ fpsnum == the min time to force a full HP/charged mobj to be deleted,
    	# (100+20)/2/20=3s
        self.maxHP=50;


        #the offset is affacted by fps
        #at 20fps for a 640*480 video input
        #we assume any object need at least 2s to go throuth the camera view
        #so w 640/2/20=16        
        
        #but in vertical direction, we assume one person's height is about 1/3 camera view's H
        #and people can use 0.5s to hold this whole body as motion region
        #h (480/3)/0.5/20=160*2/20=16

        self.posOffsetMax=16


        self.areaOffsetMax=20        
        self.sizeOffsetMax=100
        

        self.mobjCacheList =[]        
        #self.zombieList=[] #for destory

        #temporary container
        self.updateList =[];
        #self.delZBufferList =[];
        #self.createBufferList =[];

        self.scanBufferList=[];

        self.isNoDataNow =True;



    def setMode(self,execMode):
        self.execMode= execMode;
        
    def printMObj(self,mobj,header=''):
        # logger.info( '%d,%s|%d,%d,%d,%d|%d' %(obj["id"], obj["op"],obj["x"], obj["y"],obj["w"],obj["h"],obj["size"] ))
        #print 
        logger.info('%d %-8s [%4d,%4d] [%3d,%3d] %d' %( mobj["oid"],mobj["op"], mobj["xPos"], mobj["yPos"],mobj["width"],mobj["height"],mobj["cellSize"] ))
        
    def MatchObj(self,newTupleList):
        #1 clear updateList first
        self.updateList =[];

        #2 first time empty mobjCacheList ==> initMObj
        if (len(self.mobjCacheList) ==0):
            #no mobj now
            for elm in newTupleList: #elm is instance of MotionRec class
                self.initMObj({'xPos':elm.xPos,
                               'yPos':elm.yPos,
                               'height':elm.height,
                               'width':elm.width,
                               'cellSize':elm.cellSize,
                               'radial':elm.radial}
                              );
            
            return ;

        #3 compare with existing mobjcachedList
        #this 

        for mobj0 in self.mobjCacheList:
            isMatchedFlag=False;
            #delNum =0;
            delList =[];
            delNewTuple=None;
            hpInc=0

            for i in xrange(len(newTupleList)):

                #3.1 get parameters to compare
                a0 = abs(mobj0['xPos']-newTupleList[i].xPos)
                a1 = abs(mobj0['yPos']-newTupleList[i].yPos)
                a2 = abs(mobj0['height'] - newTupleList[i].height)
                a3 = abs(mobj0['width'] - newTupleList[i].width)
                a4 = abs(mobj0['cellSize'] - newTupleList[i].cellSize)
                a5 = abs(mobj0['radial'] -newTupleList[i].radial)
                #a6 = dis
                a6 = math.floor(math.sqrt(a0*a0+a1*a1))

                #3.2 check whether there is abrupt change, know as a valuejump
                jumpSum=0;
                jumpElmNameList =[]
                if a0>self.posOffsetMax:
                    jumpSum+=1;
                    jumpElmNameList.append('xPos')
                if a1>self.posOffsetMax:
                    jumpSum+=1;
                    jumpElmNameList.append('yPos')


                if a2>self.areaOffsetMax:
                    jumpSum+=1;
                    jumpElmNameList.append('height')                    
                if a3>self.areaOffsetMax:
                    jumpSum+=1;
                    jumpElmNameList.append('width')
                
                if a4>self.sizeOffsetMax or a4< newTupleList[i].cellSize*0.25:
                    jumpSum+=1;
                    jumpElmNameList.append('cellSize')
                    
                 #to fix, no jump thethold for radial value

                #if center pos of object does not change largely
                if a6<=self.posOffsetMax : 
                    xyCon=True;
                    jumpSum-=1;
                else:
                    xyCon=False;
                    
                #if area size of object does not change largely
                if a2+a3<=a5 *2.2:
                    whCon=True;
                    jumpSum-=1;
                else:
                    whCon=False;


        #we enforce to check the center position first, because if this pos get largely change it's less possible mobject become our target in this matching alg
                if xyCon:
                    isMatchedFlag=True
                    #3.3 stable Level A: position and size are both ok
                    if whCon :    
                        if( a6<=5 and a2<=5 and a3<=5 ): # active motion without big movement
                            #Lv A+: get 5 hp per frame      
                            hpInc=5
                        else:
                            #Lv A: get 3 hp per frame      
                            hpInc=3
                    else:
                        #Lv A-: obj center only in orig region
                        hpInc=2


                elif jumpSum<=2 and a6<=self.posOffsetMax*1.3 :
                    #Lv B:  get 1 hp, at least it matched sth nearby
                    hpInc=1
                    isMatchedFlag=True;
                elif (mobj0['height']!=0 and mobj0['width']!=0):
                # test whether the region get merged    
                    b1 = newTupleList[i].height/mobj0['height']
                    b2 = newTupleList[i].width/mobj0['width']
                    b3 = newTupleList[i].cellSize/mobj0['cellSize'] 
                    #b4 = a6/self.posOffsetMax
                    b5 = newTupleList[i].radial/(mobj0['radial']+a6) #a6=distance

                    # if newItem covered the orig mobj region, and size *1.5+, w-h *1.6 at least one side
                    if (b5>0.8 and b5<1.2) and b3>1.5 and ( (b1>0.8 and b2>1.6) or (b1>1.6 and b2>0.8) ):
                        isMatchedFlag=True;
                        hpInc=2

                if isMatchedFlag:
                    self.updateMObj(mobj0,newTupleList[i], jumpElmNameList,hpInc)
                    delNewTuple = newTupleList[i]
                    break; #move to next mobj

                #    print 'jumpSum:',jumpSum,'[a0-a4]',a0,a1,a2,a3,a4
            
            #===> end for i in xrange(len(newTupleList)):
            

            #3.3 if current Mobj does not match with any item in the input motion region source

            if( isMatchedFlag == False): #if all failed
            	#mobj0['HP'] += self.hpDec  
                #now update this unchanged mobj
                self.updateMObj(mobj0,None, None,self.hpDec )
                
            	#do the update & refesh


            #for those mobj need to be deleted, their hp drop very soon
            if delNewTuple:
                newTupleList.remove(delNewTuple ); #do del outside of for loop

            #3.4 remove the matched item from newTupleList
     
        
        #end     for mobj0 in self.m



        #3.5 for residual new items we create new mobj
        for new_mobj in newTupleList:
            
            self.initMObj({'xPos':new_mobj.xPos,
                           'yPos':new_mobj.yPos,
                           'height':new_mobj.height,
                           'width':new_mobj.width,
                           'cellSize':new_mobj.cellSize,
                           'radial':new_mobj.radial
                          });
      


    def initMObj(self, mobjDict):

        newID = self.regID;
        self.regID+=1;
        #print 'regID =',self.regID
        if (self.regID>1000):
            self.regID=1;
		
		#add more attr to mobject
        mobjDict['id']=newID;
        mobjDict['oid']=-1;
        mobjDict['op'] ='init'  #current op also means current status somehow
        mobjDict['HP'] = 0		#HP value for a mObj

        #mobjDict['zombieTimer'] = self.initZombieTime;
        mobjDict['ghostTimer'] =self.initGhostTime; 
        
        
        #self.updateList.append(mobjDict);
        self.mobjCacheList.append(mobjDict);
        #self.printMObj(mobjDict,'initObj:')


    #prevObj should be a mobj in cachedlist
    #currObj should be a new mobj from input list
    def updateMObj(self,prevObj, currObj,jumpElmNameList=None,hpChange=0):
            if(hpChange >0 and prevObj['HP']<= self.maxHP) or (hpChange<0) :
                prevObj['HP'] += hpChange;

            #if jump happen, save old related attr
            if(jumpElmNameList!=None):
                jumpTempVal={}
                for elmName in  jumpElmNameList:
                    jumpTempVal[elmName]=prevObj[elmName]

            if(currObj!=None):
                prevObj['xPos'] =currObj.xPos
                prevObj['yPos'] =currObj.yPos
                prevObj['width'] =currObj.width
                prevObj['height'] =currObj.height
                prevObj['cellSize'] =currObj.cellSize
                prevObj['radial'] =currObj.radial

            #recalculate the jump attr
            if(currObj!=None and jumpElmNameList!=None):
                for elmName in  jumpElmNameList:
                    prevObj[elmName] =(jumpTempVal[elmName]+prevObj[elmName])/2

                
            
            if self.isOID_MObj(prevObj): # if the item has not got a real Obj ID
                prevObj['op'] ='update'

                
                prevObj['range'] = self.judgeObjRangeOnCreate(prevObj); #['width']*prevObj['height'], prevObj['cellSize'])
                
                #skip any ring buff
                #if  prevObj['buff'].lastTimer ==0:
                #    prevObj['lifeTimer']= self.evtActiveTime;                 
        		#self.recordBuff(prevObj);

                self.updateList.append(prevObj);   
            #else:
            



    def scanMObjCache(self,sendFunc):
        scanEVT2 = threading.Event() 
        t2 = threading.Thread(target=self.__repeatScanMObjCache__, args=(scanEVT2, 0.25,self.sortMObjCache,sendFunc)) 
        print "starting scan ghost per 0.5 second" 
        t2.start() 

    def __repeatScanMObjCache__(self,event, every, action,sendFunc): 
        while True: 
            event.wait(every) 
            if event.isSet(): 
                break 
            action(sendFunc) 

    #create state && update the life-timer                       
    def sortMObjCache(self,sendFunc):

        for mobj in self.mobjCacheList:
            #if(mobj['HP']< self.minHP): #default min=-5;
            #mobj['HP']-=1;
            if self.isOID_MObj(mobj): 
                print mobj['oid'],':',mobj['HP']

            if(mobj['HP']< self.minHP): #default min=-5;
                #delete if from list
                if self.isOID_MObj(mobj):
                    #need send msg
                    mobj['op']='del' 
                    self.scanBufferList.append(mobj);
                    print"           del-oid:", mobj['oid'],'hp:',mobj['HP']


                self.mobjCacheList.remove(mobj);
                #if rm one mobj must givup any following current process about this mobj
                continue;

            if mobj['ghostTimer'] >0 :
                mobj['ghostTimer']-= 0.25;
                if mobj['ghostTimer'] ==0 and mobj['HP']>=0 : #default initghostTime is 0.75s
                    mobj['op'] ='create'
                    mobj['oid'] = self.regOID;
                    mobj['id']=-1 #set -1 flag
                    self.regOID+=1;
                    mobj['range'] = self.judgeObjRangeOnCreate(mobj)
                    mobj['lifeTimer'] = 0 #self.evtActiveTime;
                    
                    #mobj['buff']= ring_buffer(self.ringBuffLen); #use ring buff to record the last 10 data of one OID OBJ

                    #self.printMObj(mobj, "MainCreate:")
                    print"           G->oid:", mobj['oid'],'hp:',mobj['HP']
                    self.scanBufferList.append(mobj);
                    #print "[--------], ID:%d/%d,\t%s,\tx:%d\ty:%d\th:%d\tw:%d\ts:%d\t" % (mobj['id'],mobj['oid'], mobj['op'],mobj['xPos'],mobj['yPos'],mobj['height'],mobj['width'],mobj['cellSize'])
                elif mobj['ghostTimer'] ==0 and mobj['HP']<0:
                    #time up 
                    mobj['lifeTimer'] = 0
                    self.mobjCacheList.remove(mobj);                    
                    continue;

            else:
                #for those not ghost ==> have oid
                mobj['lifeTimer'] += 0.25    
               
               
        if (len(self.scanBufferList)>0):
            cList = self.composeMObjList(self.scanBufferList)
            sendFunc(cList); #call pubnub to send
            self.scanBufferList=[]

    #++++++++++++++++++++ aid functions ++++++++++++++++++++++++++++
    def isOID_MObj(self,mobjDict):
        if mobjDict.get('oid') == -1:
            return False;
        else:
            return True;

    """ used for wsf-BB
    def judgeObjRangeOnCreate(self,area,s):
        #128*96 / 640*480,
        #one people size:  60 * 100=6000/s=12*20=240 ~~~~~~~150*200, 30000 | 30*40=1200
        #2or 3 people size : 150*120=18000/ s =24*24=576 ~~~~~~  320*240,76800 |
        # more people size : 300*200= 60000 /60*40=2400 80*440, 19200
        if area>=55000 and s>1800:
            return 2; #large
        elif area >= 18000 and s>=576:#140:
            return 1;
        else:
            return 0;            
    """
    def judgeObjRangeOnCreate(self,mobj):
        #w,h,r is in the orig 640*480 scale
        #cSize is the pix counter in 128*96 scale
        #D1-ratio ==5 
        w=mobj["width"]
        h=mobj["height"]
        r=mobj["radial"]
        cSize= mobj["cellSize"]
        

        if  r <=50 and cSize<=145: #ideal is w=40 h=40 r=5.6 , about a hand size in 3m distance
            print mobj["oid"],'--->0'
            return 0;
        elif r <=60 and cSize<=210:#harf body size
            print mobj["oid"],'--->11,',w,h,r,cSize
            return 1;
        elif w<=100 and h<=100 and cSize<250: #one body size
            return 2;
        elif w<=200 and h<=200  and cSize<1000: #multi bodys size(2-3)
            return 3;
        elif w<=400 and h<=300 and cSize>1600 : #A larger region with fillRatio >0.33
            return 4;
        else:
            print mobj["oid"],'--->', w,h,r,cSize
            return -1; #unexcepted sizes


    def composeMObjList(self,objList):
        uLen =len(objList);
        if(uLen >0):
            MObjList=[]
            for mobj in objList:
    #                print "[c:%d/z:%d], ID:%d/%d,\t%s,\tx:%d\ty:%d\th:%d\tw:%d\ts:%d\t" % (len(self.mobjCacheList),len(self.zombieList),mobj['id'],mobj['oid'], mobj['op'],mobj['xPos'],mobj['yPos'],mobj['height'],mobj['width'],mobj['cellSize'])
                MObjList.append(
                        {'id':mobj['oid'],
                         'x':mobj['xPos'],
                         'y':mobj['yPos'],
                         'size':mobj['cellSize'],
                         'op':mobj['op'],
                         'h':mobj['height'],
                         'w':mobj['width'],
                         'r':mobj['range'], #range:0-s,1-m,2-l
                         't':mobj['lifeTimer'],  #time:
                         'hp':mobj['HP']
                         }         
                        )
            return MObjList
        else:
            return []